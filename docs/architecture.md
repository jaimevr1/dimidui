# Dimidui MVP Fullstack Architecture Document

## 1. Introduction
This document outlines the complete fullstack architecture for the Dimidui MVP. It is based on the approved Product Requirements Document (PRD) and the UI/UX Specification. It serves as the single source of truth for all technical implementation, guiding the AI-driven development process to ensure consistency and adherence to the project goals.

### 1.1. Starter Template or Existing Project
N/A - This is a greenfield project built from scratch according to the provided specifications.

### 1.2. Change Log
| Date       | Version | Description                | Author         |
|------------|---------|----------------------------|----------------|
| 2025-10-06 | 1.0     | Versão inicial do documento | Winston, Architect |

---

## 2. High-Level Architecture

### 2.1. Technical Summary
This project uses a modern Jamstack architecture. The frontend is a static site built with **HTML, CSS, and Vanilla JavaScript**, deployed on **Vercel**. The backend is entirely managed by **Supabase**, which provides the PostgreSQL database, authentication, and instant REST APIs. This BaaS (Backend-as-a-Service) approach minimizes backend development overhead, allowing the team to focus on frontend features and user experience, directly aligning with the goal of rapid MVP delivery in 5 weeks.

### 2.2. Platform and Infrastructure Choice
- **Platform:** Vercel + Supabase
- **Key Services:**
    - **Vercel:** Hosting for the static frontend, CI/CD, Global CDN.
    - **Supabase:** PostgreSQL Database, User Authentication (Supabase Auth), Auto-generated REST API (PostgREST), Row Level Security (RLS).
- **Deployment Host and Regions:** Vercel (Global Edge Network), Supabase (AWS region to be chosen, e.g., `us-east-1`).

### 2.3. Repository Structure
- **Structure:** Monorepo
- **Rationale:** Given the simplicity of the stack (no separate backend build process), a single repository is sufficient to house all frontend code and documentation, simplifying project management.

### 2.4. High-Level Architecture Diagram
```mermaid
graph TD
    User[Alunos & Professores] -->|HTTPS| Vercel[Vercel Edge Network]
    Vercel --> FE[Frontend Statico (HTML/JS/CSS)]
    FE -->|API Calls via supabase-js| Supabase[Supabase API Gateway]
    Supabase --> Auth[Supabase Auth]
    Supabase --> DB[(Supabase PostgreSQL DB)]

    subgraph "Supabase (Backend-as-a-Service)"
        Auth
        DB
    end
```

### 2.5. Architectural Patterns
- **Jamstack:** The frontend is a pre-built static site, interacting with backend services via APIs. This provides excellent performance, security, and scalability.
- **Backend-as-a-Service (BaaS):** Supabase abstracts the entire backend, allowing the frontend to interact directly with authentication and database services through a client library.
- **Component-Based UI (File-based):** Although not using a framework like React, the frontend logic is organized into modular JavaScript files (`/scripts/modules/*.js`), each responsible for a specific piece of UI or functionality.

---

## 3. Tech Stack
| Category | Technology | Version | Purpose | Rationale |
|---|---|---|---|---|
| Frontend Language | JavaScript | ES6+ | Core application logic | Universal, no-build-step simplicity. |
| Frontend Framework | N/A (Vanilla JS) | - | Building the user interface | Aligns with spec, lightweight, no dependencies. |
| UI Component Library | N/A (Custom CSS) | - | Styling and layout | Custom CSS in `styles/` provides full control. |
| API Style | REST | - | Communication with backend | Auto-generated by Supabase (PostgREST). |
| Database | PostgreSQL | 15+ | Primary data storage | Provided by Supabase; powerful and reliable SQL DB. |
| File Storage | Supabase Storage | - | Storing any potential assets | Integrated with Supabase, though not used in MVP spec. |
| Authentication | Supabase Auth | - | User login and session management | Secure, integrated, and provides RLS capabilities. |
| Frontend Testing | Manual | - | Quality Assurance | As per MVP scope. |
| Backend Testing | N/A | - | - | Backend logic is within Supabase; tested via frontend. |
| Build Tool | N/A | - | - | No build step required for this Vanilla JS project. |
| CI/CD | Vercel | - | Automated deployments | Git-based workflow, seamless integration. |

---

## 4. Data Models (TypeScript Interfaces)
These interfaces represent the data structures that will be used in the frontend JavaScript code when interacting with the Supabase API.

```typescript
// From /scripts/supabase-client.js or a shared types file

export interface Student {
  id: string; // UUID
  name: string;
  grade_level: 4 | 5 | 6;
  created_at: string; // ISO 8601
}

export interface Activity {
  id: string; // UUID
  name: string;
  type: 'fluencia' | 'integracao';
  bncc_codes: string[];
  estimated_duration: number; // minutes
  unlocked_by: string | null; // UUID
  modules: any[]; // JSONB
}

export interface QuestionBankItem {
  id: string; // UUID
  module_type: string; // 'm1', 'm5', etc.
  content: any; // JSONB
  tags: string[];
}

export interface StudentAttempt {
  id: string; // UUID
  student_id: string; // UUID
  activity_id: string; // UUID
  module_index: number;
  module_type: string;
  questions_data: any; // JSONB
  correct_count: number;
  total_count: number;
  accuracy: number;
  started_at: string; // ISO 8601
  completed_at: string | null; // ISO 8601
}
```

---

## 5. Database Schema
*The following SQL DDL is the source of truth for the database structure, as defined in the specification.* 

```sql
-- TABELA: students
CREATE TABLE students (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  password TEXT NOT NULL, -- plaintext no MVP (hash em prod)
  grade_level INT CHECK (grade_level IN (4,5,6)),
  created_at TIMESTAMP DEFAULT NOW()
);

-- TABELA: activities
CREATE TABLE activities (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  type TEXT CHECK (type IN ('fluencia', 'integracao')),
  bncc_codes TEXT[],
  estimated_duration INT, -- minutos
  unlocked_by UUID REFERENCES activities(id), -- NULL se sempre disponível
  modules JSONB NOT NULL, -- [{type: 'm1', config: {...}}, ...]
  created_at TIMESTAMP DEFAULT NOW()
);

-- TABELA: question_bank (novo - para reutilização)
CREATE TABLE question_bank (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  module_type TEXT, -- 'm1', 'm5', etc
  content JSONB, -- estrutura varia por módulo
  tags TEXT[],
  created_at TIMESTAMP DEFAULT NOW()
);

-- TABELA: student_attempts
CREATE TABLE student_attempts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  student_id UUID REFERENCES students(id) ON DELETE CASCADE,
  activity_id UUID REFERENCES activities(id) ON DELETE CASCADE,
  module_index INT, -- posição na cadeia
  module_type TEXT,
  
  -- Dados de desempenho
  questions_data JSONB, -- [{question_id, correct, attempts, time_spent}, ...]
  correct_count INT,
  total_count INT,
  accuracy FLOAT GENERATED ALWAYS AS (correct_count::float / NULLIF(total_count, 0)) STORED,
  
  started_at TIMESTAMP DEFAULT NOW(),
  completed_at TIMESTAMP
);

-- TABELA: activity_assignments
CREATE TABLE activity_assignments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  student_id UUID REFERENCES students(id) ON DELETE CASCADE,
  activity_id UUID REFERENCES activities(id) ON DELETE CASCADE,
  assigned_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(student_id, activity_id)
);

-- VIEW: concept_mastery
CREATE VIEW concept_mastery AS
SELECT 
  sa.student_id,
  unnest(a.bncc_codes) AS bncc_code,
  AVG(sa.accuracy) AS avg_accuracy,
  COUNT(*) AS attempts,
  MAX(sa.completed_at) AS last_practiced
FROM student_attempts sa
JOIN activities a ON sa.activity_id = a.id
WHERE sa.completed_at IS NOT NULL
GROUP BY sa.student_id, bncc_code;

-- VIEW: student_progress_summary
CREATE VIEW student_progress_summary AS
SELECT 
  s.id AS student_id,
  s.name,
  COUNT(DISTINCT sa.activity_id) FILTER (WHERE sa.completed_at IS NOT NULL) AS completed_activities,
  AVG(sa.accuracy) FILTER (WHERE sa.completed_at IS NOT NULL) AS overall_accuracy,
  COUNT(DISTINCT cm.bncc_code) FILTER (WHERE cm.avg_accuracy >= 0.70) AS mastered_concepts
FROM students s
LEFT JOIN student_attempts sa ON s.id = sa.student_id
LEFT JOIN concept_mastery cm ON s.id = cm.student_id
GROUP BY s.id, s.name;
```

---

## 6. Frontend Architecture

### 6.1. Component Architecture
- **Component Organization**: A file-based module system will be used. Each core piece of functionality is encapsulated in its own JavaScript file within `/scripts/`. UI-centric modules responsible for rendering activities are in `/scripts/modules/`.
- **State Management**: State will be managed locally within each script. There is no global state management library. For session state (like the logged-in user), `localStorage` or `sessionStorage` will be used to store the student's ID and session token.

### 6.2. Routing Architecture
- **Routing**: Static file-based routing. Navigation between pages (`login.html`, `aluno-dashboard.html`, etc.) is handled by standard HTML links (`<a>` tags) or `window.location.href` assignments in JavaScript.
- **Protected Routes**: A check will be implemented at the beginning of each page's script (e.g., `dashboard.js`) to verify if a user session exists in `localStorage`. If not, the user will be redirected to `login.html`.

### 6.3. Frontend Services Layer
- **API Client**: A single Supabase client instance will be initialized in `/scripts/supabase-client.js` and exported for use across all other scripts. This ensures all database and auth interactions go through a single, consistent point.

---

## 7. Unified Project Structure
```plaintext
/dimidui-mvp
├── /assets
│   ├── /fonts (Atkinson Hyperlegible)
│   └── /icons (Lucide SVG)
├── /styles
│   ├── variables.css (design tokens)
│   ├── global.css
│   └── modules.css
├── /scripts
│   ├── supabase-client.js
│   ├── auth.js
│   ├── modules/
│   │   ├── m1-bateria.js
│   │   ├── m2-linha.js
│   │   ├── m5-operacao.js
│   │   ├── m6-palavra.js
│   │   ├── m8-ortografia.js
│   │   └── m9-leitura.js
│   ├── activity-runtime.js
│   └── dashboard.js
├── login.html
├── aluno-dashboard.html
├── atividade.html (runtime genérico)
├── professor-dashboard.html
├── professor-criar.html
└── professor-banco-questoes.html
```

---

## 8. Coding Standards
- **Supabase Client**: All interactions with Supabase MUST be done through the exported client from `/scripts/supabase-client.js`. Do not initialize new clients elsewhere.
- **Environment Variables**: Supabase URL and Anon Key must be stored in environment variables and not hardcoded. A `.env.example` file should be provided.
- **CSS**: All colors, fonts, and spacing values must be defined as CSS variables in `variables.css` and used throughout the application.
- **Error Handling**: All calls to Supabase must be wrapped in `try...catch` blocks to handle potential API or network errors gracefully.
- **Naming Conventions**:
    - JavaScript files: `kebab-case.js`
    - CSS classes: `kebab-case`
    - JS Functions: `camelCase()`

---

## 9. Deployment Architecture
- **Strategy**: The project will be deployed as a static site on Vercel. The Vercel project will be connected to the GitHub repository.
- **CI/CD Pipeline**: Any push or merge to the `main` branch will automatically trigger a new deployment on Vercel. No complex build steps are needed.
- **Environments**:
    - **Production**: The live application, connected to the production Supabase project.
    - **Preview**: Vercel will automatically create preview deployments for each pull request, which can be connected to a separate staging Supabase project.
