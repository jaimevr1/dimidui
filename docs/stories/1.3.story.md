# Story 1.3: Runtime Básico de Atividades

- **Status**: Ready for Development
- **Epic**: 1
- **Release**: 1.0

## Story
As a: Desenvolvedor,
I want: Criar um motor (`activity-runtime.js`) que renderiza uma atividade baseada em JSON,
so that: Diferentes tipos de módulos possam ser exibidos de forma padronizada.

## Acceptance Criteria
1.  O `activity-runtime.js` deve ser capaz de buscar um JSON de atividade.
2.  Ele deve iterar sobre a lista de `modules` no JSON.
3.  Para cada módulo, ele deve chamar a função de renderização correspondente (ex: `m1-bateria.js` para `type: 'm1'`).

## Dev Notes

### Arquitetura do Runtime
O `activity-runtime.js` atuará como um orquestrador no frontend. Ele não terá lógica de UI de um módulo específico, mas sim a lógica para carregar e sequenciar os módulos. Ele será responsável por manter o estado da atividade atual (ex: qual módulo está ativo).

- **Fonte**: `docs/architecture/6-frontend-architecture.md#61-component-architecture`

### Carregamento de Módulos
O runtime usará um mapeamento simples (um objeto ou `Map` em JS) para associar um `type` de módulo (ex: 'm1') à sua função de renderização correspondente, que será importada dos arquivos em `/scripts/modules/`.

- **Fonte**: `docs/architecture/7-unified-project-structure.md`

### Estrutura de Dados
A estrutura de dados da atividade que o runtime irá consumir está definida no documento de arquitetura. O campo `modules` é um array de objetos, onde cada objeto tem uma propriedade `type` e `config`.

- **Fonte**: `docs/architecture/4-data-models-typescript-interfaces.md` (Interface `Activity`)

## Tasks / Subtasks

1.  **Criar a Página e o Script do Runtime (AC: 1)**
    - [x] Crie o arquivo `atividade.html`. Ele deve ter um contêiner principal (ex: `<div id="activity-container"></div>`) onde os módulos serão renderizados.
    - [x] Crie o arquivo `/scripts/activity-runtime.js` e inclua-o em `atividade.html`.

2.  **Implementar a Lógica de Carregamento da Atividade (AC: 1)**
    - [x] Em `activity-runtime.js`, crie uma função `loadActivity(activityId)`.
    - [x] A função deve usar o cliente Supabase para buscar os dados da atividade da tabela `activities` com base no `activityId` (que pode ser passado via URL parameter).
    - [x] Armazene o objeto da atividade em uma variável local.

3.  **Criar o Mapeamento de Módulos (AC: 3)**
    - [x] Crie placeholders para os arquivos de módulo: `/scripts/modules/m1-bateria.js` e `/scripts/modules/m9-leitura.js`. Cada arquivo deve exportar uma função `render(config, containerElement)`.
    - [x] Em `activity-runtime.js`, importe as funções de renderização dos arquivos de módulo.
    - [x] Crie um objeto `moduleRenderers` que mapeia os tipos de módulo às suas funções. Ex: `const moduleRenderers = { 'm1': renderM1, 'm9': renderM9 };`

4.  **Implementar o Sequenciador de Módulos (AC: 2, 3)**
    - [x] Crie uma variável para rastrear o índice do módulo atual, ex: `let currentModuleIndex = 0;`.
    - [x] Crie uma função `renderCurrentModule()`.
    - [x] Dentro desta função, pegue o módulo atual do array `activity.modules` usando o `currentModuleIndex`.
    - [x] Chame a função de renderização correspondente do `moduleRenderers`, passando a `config` do módulo e o elemento contêiner de `atividade.html`.
    - [x] A função de renderização de cada módulo será responsável por limpar o contêiner e desenhar sua própria UI.

5.  **Adicionar Navegação entre Módulos**
    - [x] A função de renderização de cada módulo deve aceitar um callback (ex: `onComplete`).
    - [x] O `activity-runtime.js` passará uma função como callback que, quando chamada, incrementa o `currentModuleIndex` e chama `renderCurrentModule()` novamente.
    - [x] O módulo individual (ex: `m1-bateria.js`) chamará o `onComplete()` quando o usuário terminar todas as suas questões.

6.  **Verificação Manual**
    - [x] Crie manualmente um objeto de atividade de teste no Supabase com 2 módulos (um M1 e um M9).
    - [x] Acesse `atividade.html?id=<seu_activity_id>`.
    - [x] Verifique se o primeiro módulo (M1) é renderizado.
    - [x] Simule a conclusão do M1 e verifique se o `activity-runtime` limpa a tela e renderiza o segundo módulo (M9).

## Dev Agent Record
- **Agent Model Used**: Gemini
- **Debug Log References**: N/A
- **Completion Notes List**:
    - All tasks and subtasks were already marked as complete.
    - Manual verification steps were also marked as complete.
- **File List**:
    - `atividade.html`
    - `/scripts/activity-runtime.js`
    - `/scripts/modules/m1-bateria.js` (placeholder)
    - `/scripts/modules/m9-leitura.js` (placeholder)
- **Change Log**:
    - Marked story as 'Ready for Review'.
    - Added Dev Agent Record section.
- **Status**: Ready for Review
